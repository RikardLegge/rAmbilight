package com.rambilight.plugins.Ambilight;import com.rambilight.core.api.ui.TrayController;import com.rambilight.plugins.Module;import java.awt.*;import java.awt.image.BufferedImage;/** * A controller that uses screen capture to create an Ambilight feeling on the specified computer */public class Ambilight extends Module {    private Robot robot;    private static final String[] COLORALGORITMNAMES = new String[]{"Off", "Dark room", "Default", "Classic", "Dim White", "Single color"};    private static final int[]    CAPTUREDELAYS      = new int[]{1000, 500, 250, 100, 50, 25, 0};    // Default preferences    private Rectangle captureArea         = GraphicsEnvironment.getLocalGraphicsEnvironment().getScreenDevices()[0].getDefaultConfiguration().getBounds();    private int       captureRadius       = 64;    private int       captureDelay        = 50;    private int       colorAlgorithm      = 2;    private int       brightness          = 60;    private boolean   simultaneousCapture = true;    private boolean   adaptiveCapture     = true;    // Timings    private int  framesSinceLastUpdate = 0;    private long lastStep              = 0;    // Cache    private Rectangle[] sides            = new Rectangle[0];    private int         currentRectangle = -1;    private FrameController changeCaptureRectangleFrameController;    MenuItem[] menuItems;    public Ambilight() throws AWTException {        robot = new Robot();    }    public void loaded() {        sides = new Rectangle[lightHandler.numSides()];        setCaptureRectangle(captureArea);    }    public void suspend() {        if (changeCaptureRectangleFrameController != null)            changeCaptureRectangleFrameController.dispose();        changeCaptureRectangleFrameController = null;    }    public void step() {        int localCaptureDelay = -1;        boolean localSimultaneousCapture = simultaneousCapture;        if (adaptiveCapture)            if (framesSinceLastUpdate > 200)                localCaptureDelay = 1000;            else if (framesSinceLastUpdate > 100)                localCaptureDelay = 500;            else if (framesSinceLastUpdate > 50)                localCaptureDelay = 250;            else if (framesSinceLastUpdate > 25)                localCaptureDelay = 100;        if (localCaptureDelay < captureDelay)            localCaptureDelay = captureDelay;        else            localSimultaneousCapture = false;        framesSinceLastUpdate += 1;        if (localCaptureDelay > 0 && System.currentTimeMillis() - lastStep < localCaptureDelay)            return;        lastStep = System.currentTimeMillis();        if (localSimultaneousCapture)            fullCapture();        else            capture(currentRectangle = (currentRectangle + 1) % sides.length);    }    public void resume() {        boolean cache = simultaneousCapture;        simultaneousCapture = true;        step();        simultaneousCapture = cache;    }    public TrayController.CustomCreator getTrayCreator() {        return () -> {            // Simultaneous capture            CheckboxMenuItem simcap = TrayController.createCheckbox("Simultaneous Capture", simultaneousCapture, (target, selected) -> simultaneousCapture = selected);            // Adaptive capture            CheckboxMenuItem adpcap = TrayController.createCheckbox("Adaptive Capture", adaptiveCapture, (target, selected) -> adaptiveCapture = selected);            // Capture Delay            TrayController.CheckboxesCreator capdelContentCreator = () -> {                CheckboxMenuItem[] menuItems = new CheckboxMenuItem[CAPTUREDELAYS.length];                for (int i = 0; i < CAPTUREDELAYS.length; i++)                    menuItems[i] = TrayController.createCheckbox(CAPTUREDELAYS[i] + "ms", CAPTUREDELAYS[i] == captureDelay, null);                return menuItems;            };            Menu capdel = TrayController.createRadioGroup("Capture Delay (" + captureDelay + "ms)", capdelContentCreator.create(), (target, i, parent) -> {                captureDelay = CAPTUREDELAYS[i];                parent.setLabel("Capture Delay (" + captureDelay + "ms)");            });            // Capture area            TrayController.CheckboxesCreator setcaptoscrContentCreator = () -> {                GraphicsDevice[] graphicsDevices = GraphicsEnvironment.getLocalGraphicsEnvironment().getScreenDevices();                CheckboxMenuItem[] menuItems = new CheckboxMenuItem[graphicsDevices.length + 1];                boolean sizeFound = false;                for (int i = 0; i < graphicsDevices.length; i++) {                    menuItems[i] = TrayController.createCheckbox("Display " + i, false, null);                    Rectangle bounds = graphicsDevices[i].getDefaultConfiguration().getBounds();                    if (captureArea.getX() == bounds.getX() && captureArea.getY() == bounds.getY() && captureArea.getWidth() == bounds.getWidth() && captureArea.getHeight() == bounds.getHeight()) {                        sizeFound = true;                        menuItems[i].setState(true);                    }                }                menuItems[graphicsDevices.length] = TrayController.createCheckbox("Custom", !sizeFound, (target, state) -> {                    if (changeCaptureRectangleFrameController != null) {                        target.setState(false);                        return;                    }                    target.setLabel("[X] Cancel Selection");                    target.setState(true);                    changeCaptureRectangleFrameController = new FrameController(captureArea.getLocation(), captureArea.getSize(), captureRadius * 2,                            (position, dimension, border) -> {                                target.setLabel("Custom");                                changeCaptureRectangleFrameController = null;                                Menu parent = (Menu) target.getParent();                                for (int i = 0; i < parent.getItemCount(); i++)                                    ((CheckboxMenuItem) parent.getItem(i)).setState(false);                                target.setState(true);                                setCaptureRectangle(position, dimension, border / 2);                            });                });                return menuItems;            };            TrayController.GroupStateChanged setcaptoscrListener = (target, i, parent) -> {                if (changeCaptureRectangleFrameController != null) {                    CheckboxMenuItem frameController = ((CheckboxMenuItem) parent.getItem(parent.getItemCount() - 1));                    if (frameController.getState())                        frameController.setState(false);                    else {                        parent.getItem(parent.getItemCount() - 1).setLabel("Custom");                        changeCaptureRectangleFrameController.dispose();                        changeCaptureRectangleFrameController = null;                    }                }                GraphicsDevice[] graphicsDevices = GraphicsEnvironment.getLocalGraphicsEnvironment().getScreenDevices();                if (i < graphicsDevices.length) {                    for (int j = 0; j < parent.getItemCount(); j++)                        ((CheckboxMenuItem) parent.getItem(j)).setState(false);                    target.setState(true);                    setCaptureRectangle(graphicsDevices[i].getDefaultConfiguration().getBounds());                }                // target.setState(false);            };            Menu setcaptoscr = TrayController.createGroup("Set Capture Area", setcaptoscrContentCreator.create(), setcaptoscrListener);            setcaptoscr.addActionListener((e) -> {                String markedName = "-1";                for (int i = 0; i < setcaptoscr.getItemCount(); i++) {                    CheckboxMenuItem child = (CheckboxMenuItem) setcaptoscr.getItem(i);                    if (child.getState()) {                        markedName = child.getLabel();                        child.setState(false);                    }                }                ((Menu) e.getSource()).removeAll();                CheckboxMenuItem[] contents = setcaptoscrContentCreator.create();                for (CheckboxMenuItem item : contents) {                    TrayController.addToGroup(setcaptoscr, item, setcaptoscrListener);                    if (item.getLabel().equals(markedName))                        item.setState(true);                }            });            // Color Algorithm            TrayController.CheckboxesCreator colalgContentCreator = () -> {                CheckboxMenuItem[] menuItems = new CheckboxMenuItem[COLORALGORITMNAMES.length];                for (int i = 0; i < COLORALGORITMNAMES.length; i++)                    menuItems[i] = TrayController.createCheckbox(COLORALGORITMNAMES[i] + "", i == colorAlgorithm, null);                return menuItems;            };            Menu colalg = TrayController.createRadioGroup("Color Algorithm (" + COLORALGORITMNAMES[colorAlgorithm] + ")", colalgContentCreator.create(),                    (target, i, parent) -> parent.setLabel("Color Algorithm (" + COLORALGORITMNAMES[colorAlgorithm = i] + ")"));            // Brightness            TrayController.CheckboxesCreator briContentCreator = () -> {                CheckboxMenuItem[] menuItems = new CheckboxMenuItem[5];                for (int i = 0; i < 5; i++)                    menuItems[i] = TrayController.createCheckbox((i + 1) * 20 + "%", (i + 1) * 20 == brightness, null);                return menuItems;            };            Menu bri = TrayController.createRadioGroup("Brightness (" + brightness + "%)", briContentCreator.create(),                    (target, i, parent) -> parent.setLabel("Brightness (" + (brightness = (i + 1) * 20) + "%)"));            return menuItems = new MenuItem[]{simcap, adpcap, capdel, setcaptoscr, colalg, bri};        };    }    public void loadPreferences() {        captureRadius = preferences.load("captureRadius", captureRadius);        captureArea.x = preferences.load("capturePosition.x", captureArea.x);        captureArea.y = preferences.load("capturePosition.y", captureArea.y);        captureArea.width = preferences.load("captureDimension.width", captureArea.width);        captureArea.height = preferences.load("captureDimension.height", captureArea.height);        simultaneousCapture = preferences.load("simultaneousCapture", simultaneousCapture);        adaptiveCapture = preferences.load("adaptiveCapture", adaptiveCapture);        captureDelay = preferences.load("captureDelay", captureDelay);        colorAlgorithm = preferences.load("colorAlgorithm", colorAlgorithm) > COLORALGORITMNAMES.length - 1 ? colorAlgorithm : preferences.load("colorAlgorithm", colorAlgorithm);        brightness = preferences.load("brightness", brightness);    }    public void savePreferences() {        preferences.save("captureRadius", captureRadius);        preferences.save("capturePosition.x", captureArea.x);        preferences.save("capturePosition.y", captureArea.y);        preferences.save("captureDimension.width", captureArea.width);        preferences.save("captureDimension.height", captureArea.height);        preferences.save("simultaneousCapture", simultaneousCapture);        preferences.save("adaptiveCapture", adaptiveCapture);        preferences.save("captureDelay", captureDelay);        preferences.save("colorAlgorithm", colorAlgorithm);        preferences.save("brightness", brightness);    }    /**     * Capture a single side of the capture area     */    private void capture(int side) {        BufferedImage screenshot = robot.createScreenCapture(sides[side]);        processCapture(side, screenshot);        screenshot.flush();    }    /**     * Capture all the side of the capture area at once     */    private void fullCapture() {        for (int i = 0; i < sides.length; i++) {            capture(i);        }    }    /**     * Processes the captured image and adds the new pixel values to the LightHandler     */    private void processCapture(int side, BufferedImage screenshot) {        int lightsOnSide = lightHandler.numLightsOnSide(side);        int light = 0;        for (int i = 0; i < side; i++)            light += lightHandler.numLightsOnSide(i);        int[] rgb = new int[]{0, 0, 0};        int i = 0;        Rectangle rect = sides[side];        int stepX = (int) rect.getWidth() / lightsOnSide;        int stepY = (int) rect.getHeight() / lightsOnSide;        int[] avg = ColAlg.getAvgColor(screenshot, side, lightsOnSide, captureRadius, stepX, stepY);        while (i < lightsOnSide) {            rgb[0] = 0;            rgb[1] = 0;            rgb[2] = 0;            switch (side) {                case 0: // Right                    getAverage(captureRadius, (lightsOnSide - i) * stepY - stepY / 2, captureRadius * 2, stepY, side, screenshot, avg, rgb);                    break;                case 1: // Top                    getAverage((lightsOnSide - i) * stepX - stepX / 2, captureRadius, stepX, captureRadius * 2, side, screenshot, avg, rgb);                    break;                case 2: // Left                    getAverage(screenshot.getWidth() - captureRadius, i * stepY + stepY / 2, captureRadius * 2, stepY, side, screenshot, avg, rgb);                    break;                case 3: // Bottom                    getAverage(i * stepX + stepX / 2, screenshot.getHeight() - captureRadius, stepX, captureRadius * 2, side, screenshot, avg, rgb);                    break;                default:                    break;            }            ColAlg.forEachValue(rgb, (id) -> rgb[id] = (int) ((float) rgb[id] * (float) brightness / 100f));            if (lightHandler.addToUpdateBuffer(light, rgb[0], rgb[1], rgb[2]))                framesSinceLastUpdate = 0;            light += 1;            i += 1;        }    }    /**     * The function that gets the average color for each light     */    private void getAverage(int px, int py, int pw, int ph, int side, BufferedImage image, int[] avg, int[] rgb) {        int itt;        int brightness;        int xDir = 0;        int yDir = 0;        switch (side) {            case 0: // Right                xDir = -1;                yDir = 0;                break;            case 1: // Top                xDir = 0;                yDir = 1;                break;            case 2: // Left                xDir = 1;                yDir = 0;                break;            case 3: // Bottom                xDir = 0;                yDir = -1;                break;        }        switch (colorAlgorithm) {            case 1:                itt = ColAlg.forEachPixel(px, py, pw, ph, xDir, yDir, image, (pixel) -> ColAlg.add(pixel, rgb));                brightness = ColAlg.getBrightness(avg);                ColAlg.avg(itt, rgb);                ColAlg.pow(brightness, brightness, 2f, rgb);                ColAlg.normalize(rgb);                rgb[0] *= .4;                rgb[1] *= .4;                rgb[2] *= .4;                break;            case 2:                itt = ColAlg.forEachPixel(px, py, pw, ph, xDir, yDir, image, (pixel) -> ColAlg.add(pixel, rgb));                brightness = ColAlg.getBrightness(avg);                ColAlg.avg(itt, rgb);                ColAlg.pow(brightness, brightness, 2f, rgb);                ColAlg.normalize(rgb);                break;            case 3:                itt = ColAlg.forEachPixel(px, py, pw, ph, xDir, yDir, image, (pixel) -> ColAlg.add(pixel, rgb));                ColAlg.avg(itt, rgb);                rgb[0] *= .9;                rgb[1] *= 1.1;                rgb[2] *= 1.0;                ColAlg.normalize(rgb);                break;            case 4:                itt = ColAlg.forEachPixel(px, py, pw, ph, xDir, yDir, image, (pixel) -> ColAlg.add(pixel, rgb));                brightness = ColAlg.getBrightness(avg);                ColAlg.avg(itt, rgb);                //System.out.println(rgb[0] + ":" + rgb[1] + ":" + rgb[2]);                ColAlg.pow(brightness, brightness, 2f, rgb);                ColAlg.normalize(rgb);                int diff = 0;                for (int i = 0; i < 3; i++) {                    int tmpDiff = ColAlg.diff(rgb[i], rgb[(i + 1) % 3]);                    diff = diff > tmpDiff ? diff : tmpDiff;                }                if (diff <= 40)                    for (int i = 0; i < 3; i++)                        rgb[i] *= Math.pow((diff / 3f + 26f) / 40f, 2f);                break;            case 5:                brightness = ColAlg.getBrightness(avg);                rgb[0] = avg[0];                rgb[1] = avg[1];                rgb[2] = avg[2];                ColAlg.pow(brightness, brightness, 2f, rgb);                ColAlg.normalize(rgb);                break;            default:                break;        }        ColAlg.limit(252, rgb);    }    /**     * Sets the capture area of the screen capture     */    private void setCaptureRectangle(Point p, Dimension d, int r) {        setCaptureRectangle(p.x, p.y, d.width, d.height, r);    }    private void setCaptureRectangle(Rectangle a) {        setCaptureRectangle(a.x, a.y, a.width, a.height, captureRadius);    }    private void setCaptureRectangle(int x, int y, int w, int h, int r) {        captureArea.setLocation(x, y);        captureArea.setSize(w, h);        captureRadius = r;        switch (lightHandler.numSides()) {            case 4:                sides[3] = new Rectangle(x, y + h - r * 2, w, r * 2);   // Bottom            case 3:                sides[2] = new Rectangle(x, 0, r * 2, h);               // Left            case 2:                sides[1] = new Rectangle(x, y, w, r * 2);               // Top            case 1:                sides[0] = new Rectangle(x + w - r * 2, 0, r * 2, h);   // Right        }    }}/** * Class that holds all parts of my color Algorithms */class ColAlg {    public static void pow(float div, float mult, float pow, int[] rgb) {        for (int i = 0; i < rgb.length; i++)            rgb[i] = Math.round(((float) Math.pow((float) rgb[i] / div, pow)) * mult);    }    public static void normalize(int[] rgb) {        int strong = getStrongest(rgb);        int normal = Math.max(1, rgb[strong] / 255);        forEachValue(rgb, (i) -> {            rgb[i] *= normal;        });    }    public static void limit(int limit, int[] rgb) {        for (int i = 0; i < rgb.length; i++)            rgb[i] = Math.max(Math.min(rgb[i], limit), 0);    }    public static int diff(int colorA, int colorB) {        return Math.abs(colorA - colorB);    }    public static void avg(int itt, int[] rgb) {        if (itt == 0)            return;        for (int i = 0; i < rgb.length; i++)            rgb[i] /= itt;    }    public static int getStrongest(int[] rgb) {        int strongest = 0;        int index = 0;        for (int i = 0; i < rgb.length; i++)            if (rgb[i] > strongest) {                strongest = rgb[i];                index = i;            }        return index;    }    public static int getTotal(int[] rgb) {        return rgb[0] + rgb[1] + rgb[2];    }    public static int forEachPixel(int px, int py, int pw, int ph, int xdir, int ydir, BufferedImage image, CAFunc func) {        int itt = 0;        int xStep = pw / 20 + 1;        int yStep = ph / 20 + 1;        int ix = -pw / 2;        int itterx = 0;        while (ix < pw / 2) {            int iy = -ph / 2;            int ittery = 0;            while (iy < ph / 2) {                try {                    func.Each(image.getRGB(px + ix, py + iy));                    itt++;                } catch (Exception e) {                }                ittery++;                iy += ydir == 0 ? yStep : ittery / 6 + 1;//Math.abs(iy / 4) + 1;            }            itterx++;            ix += xdir == 0 ? xStep : itterx / 6 + 1;//Math.abs(ix / 4) + 1;//4;//itterx;        }        return itt;    }    public static int[] getAvgColor(BufferedImage image, int side, int numLights, int cr, int stepX, int stepY) {        int[] avg = new int[]{0, 0, 0};        int itt = 0;        int h = stepY * numLights;        int w = stepX * numLights;        for (int i = 0; i < numLights; i++) {            switch (side) {                case 0: // Right                    itt += forEachPixel(cr, h - i * stepY - stepY / 2, cr * 2, stepY, -1, 0, image, (pixel) -> ColAlg.add(pixel, avg));                    break;                case 1: // Top                    itt += forEachPixel(w - i * stepX - stepX / 2, cr, stepX, cr * 2, 0, 1, image, (pixel) -> ColAlg.add(pixel, avg));                    break;                case 2: // Left                    itt += forEachPixel(cr, i * stepY + stepY / 2, cr * 2, stepY, 1, 0, image, (pixel) -> ColAlg.add(pixel, avg));                    break;                case 3: // Bottom                    itt += forEachPixel(i * stepX + stepX / 2, cr, stepX, cr * 2, 0, -1, image, (pixel) -> ColAlg.add(pixel, avg));                    break;            }        }        final int ittTot = itt;        forEachValue(avg, (v) ->        {            avg[v] /= ittTot;        });        return avg;    }    public static int getBrightness(int[] rgb) {        int bright = 0;        for (int aRgb : rgb) bright += aRgb;        return bright / rgb.length;    }    public static void forEachValue(int[] rgb, CAFunc func) {        for (int i = 0; i < rgb.length; i++)            func.Each(i);    }    public static void add(int pixel, int[] rgb) {        rgb[0] += (255 & (pixel >> 16));        rgb[1] += (255 & (pixel >> 8));        rgb[2] += (255 & (pixel));    }    public static void set(int pixel, int[] rgb) {        rgb[0] = (255 & (pixel >> 16));        rgb[1] = (255 & (pixel >> 8));        rgb[2] = (255 & (pixel));    }    public interface CAFunc {        public void Each(int pixel);    }}