package com.rambilight.plugins.Ambilight;import com.rambilight.core.api.Global;import com.rambilight.core.api.ui.TrayController;import com.rambilight.plugins.Ambilight.extensions.Classic;import com.rambilight.plugins.Ambilight.extensions.Default;import com.rambilight.plugins.Ambilight.extensions.DimWhite;import com.rambilight.plugins.Ambilight.extensions.SingleColor;import com.rambilight.plugins.Module;import com.rambilight.plugins.extensions.Extension;import java.awt.*;import java.awt.geom.Area;import java.awt.image.BufferedImage;import java.util.*;import java.util.List;/** * A controller that uses screen capture to create an Ambilight feeling on the specified computer */public class Ambilight extends Module {    private Robot robot;    private static final int[] CAPTUREDELAYS = new int[]{1000, 500, 250, 100, 50, 25, 0};    // Default preferences    private Rectangle captureArea                   = GraphicsEnvironment.getLocalGraphicsEnvironment().getScreenDevices()[0].getDefaultConfiguration().getBounds();    private String    colorAlgorithm                = "Default";    private int       captureRadius                 = 64;    private int       captureDelay                  = 50;    private int       brightness                    = 60;    private int       algorithmDefaultColorSuppress = 3;    private boolean   simultaneousCapture           = true;    private boolean   adaptiveCapture               = true;    // Timings    private int  framesSinceLastUpdate = 0;    private long lastStep              = 0;    // Cache    private Rectangle[] sides            = new Rectangle[0];    private int         currentRectangle = -1;    private FrameController changeCaptureRectangleFrameController;    MenuItem[] menuItems;    private List<String>         colorAlgorithmNames = new ArrayList<>();    private List<ColorAlgorithm> colorAlgorithms     = new ArrayList<>();    private ColorAlgorithm currentColorAlgorithm;    public Ambilight() throws AWTException {        robot = new Robot();        addColorAlgorithm(new Default());        addColorAlgorithm(new DimWhite());        addColorAlgorithm(new SingleColor());        addColorAlgorithm(new Classic());    }    public void loaded() {        sides = new Rectangle[lightHandler.numSides()];        setCaptureRectangle(captureArea);    }    public void suspend() {        if (changeCaptureRectangleFrameController != null)            changeCaptureRectangleFrameController.dispose();        changeCaptureRectangleFrameController = null;    }    public void step() {        int localCaptureDelay = -1;        boolean localSimultaneousCapture = simultaneousCapture;        if (adaptiveCapture)            if (framesSinceLastUpdate > 256)                localCaptureDelay = 1000;            else if (framesSinceLastUpdate > 128)                localCaptureDelay = 500;            else if (framesSinceLastUpdate > 64)                localCaptureDelay = 250;            else if (framesSinceLastUpdate > 32)                localCaptureDelay = 100;        if (localCaptureDelay < captureDelay)            localCaptureDelay = captureDelay;        else            localSimultaneousCapture = false;        framesSinceLastUpdate += 1;        if (localCaptureDelay > 0 && System.currentTimeMillis() - lastStep < localCaptureDelay)            return;        lastStep = System.currentTimeMillis();        if (localSimultaneousCapture)            fullCapture();        else            capture(currentRectangle = (currentRectangle + 1) % sides.length);    }    public void resume() {        boolean cache = simultaneousCapture;        simultaneousCapture = true;        step();        simultaneousCapture = cache;    }    public TrayController.CustomCreator getTrayCreator() {        return () -> {            // Simultaneous capture            CheckboxMenuItem simcap = TrayController.createCheckbox("Simultaneous Capture", simultaneousCapture, (target, selected) -> simultaneousCapture = selected);            // Adaptive capture            CheckboxMenuItem adpcap = TrayController.createCheckbox("Adaptive Capture", adaptiveCapture, (target, selected) -> adaptiveCapture = selected);            // Capture Delay            TrayController.CheckboxesCreator capdelContentCreator = () -> {                CheckboxMenuItem[] menuItems = new CheckboxMenuItem[CAPTUREDELAYS.length];                for (int i = 0; i < CAPTUREDELAYS.length; i++)                    menuItems[i] = TrayController.createCheckbox(CAPTUREDELAYS[i] + "ms", CAPTUREDELAYS[i] == captureDelay, null);                return menuItems;            };            Menu capdel = TrayController.createRadioGroup("Capture Delay (" + captureDelay + "ms)", capdelContentCreator.create(), (target, i, parent) -> {                captureDelay = CAPTUREDELAYS[i];                parent.setLabel("Capture Delay (" + captureDelay + "ms)");            });            // Capture area            TrayController.CheckboxesCreator setcaptoscrContentCreator = () -> {                GraphicsDevice[] graphicsDevices = GraphicsEnvironment.getLocalGraphicsEnvironment().getScreenDevices();                CheckboxMenuItem[] menuItems = new CheckboxMenuItem[graphicsDevices.length + 2];                boolean sizeFound = false;                for (int i = 0; i < graphicsDevices.length; i++) {                    menuItems[i] = TrayController.createCheckbox("Display " + i, false, null);                    Rectangle bounds = graphicsDevices[i].getDefaultConfiguration().getBounds();                    if (captureArea.getX() == bounds.getX() && captureArea.getY() == bounds.getY() && captureArea.getWidth() == bounds.getWidth() && captureArea.getHeight() == bounds.getHeight()) {                        sizeFound = true;                        menuItems[i].setState(true);                    }                }                menuItems[graphicsDevices.length] = TrayController.createCheckbox("Custom", !sizeFound, (target, state) -> {                    if (changeCaptureRectangleFrameController != null) {                        target.setState(false);                        return;                    }                    target.setLabel("[X] Cancel Selection");                    target.setState(true);                    changeCaptureRectangleFrameController = new FrameController(captureArea.getLocation(), captureArea.getSize(), captureRadius * 2,                            (position, dimension, border) -> {                                target.setLabel("Custom");                                changeCaptureRectangleFrameController = null;                                Menu parent = (Menu) target.getParent();                                for (int i = 0; i < parent.getItemCount(); i++)                                    ((CheckboxMenuItem) parent.getItem(i)).setState(false);                                target.setState(true);                                setCaptureRectangle(position, dimension, border / 2);                            });                });                menuItems[graphicsDevices.length + 1] = TrayController.createCheckbox("Detect black bars", false, (target, state) -> {                    Menu parent = (Menu) target.getParent();                    for (int i = 0; i < parent.getItemCount(); i++)                        ((CheckboxMenuItem) parent.getItem(i)).setState(false);                    target.setState(true);                    Rectangle area = detectBlackBars();                    setCaptureRectangle(area.getLocation(), area.getSize(), captureRadius);                });                return menuItems;            };            TrayController.GroupStateChanged setcaptoscrListener = (target, i, parent) -> {                if (changeCaptureRectangleFrameController != null) {                    CheckboxMenuItem frameController = ((CheckboxMenuItem) parent.getItem(parent.getItemCount() - 2));                    if (frameController.getState())                        frameController.setState(false);                    else {                        parent.getItem(parent.getItemCount() - 2).setLabel("Custom");                        changeCaptureRectangleFrameController.dispose();                        changeCaptureRectangleFrameController = null;                    }                }                GraphicsDevice[] graphicsDevices = GraphicsEnvironment.getLocalGraphicsEnvironment().getScreenDevices();                if (i < graphicsDevices.length) {                    for (int j = 0; j < parent.getItemCount(); j++)                        ((CheckboxMenuItem) parent.getItem(j)).setState(false);                    target.setState(true);                    setCaptureRectangle(graphicsDevices[i].getDefaultConfiguration().getBounds());                }                // target.setState(false);            };            Menu setcaptoscr = TrayController.createGroup("Set Capture Area", setcaptoscrContentCreator.create(), setcaptoscrListener);            setcaptoscr.addActionListener((e) -> {                String markedName = "-1";                for (int i = 0; i < setcaptoscr.getItemCount(); i++) {                    CheckboxMenuItem child = (CheckboxMenuItem) setcaptoscr.getItem(i);                    if (child.getState()) {                        markedName = child.getLabel();                        child.setState(false);                    }                }                ((Menu) e.getSource()).removeAll();                CheckboxMenuItem[] contents = setcaptoscrContentCreator.create();                for (CheckboxMenuItem item : contents) {                    TrayController.addToGroup(setcaptoscr, item, setcaptoscrListener);                    if (item.getLabel().equals(markedName))                        item.setState(true);                }            });            // Color Algorithm            TrayController.CheckboxesCreator colalgContentCreator = () -> {                CheckboxMenuItem[] menuItems = new CheckboxMenuItem[colorAlgorithmNames.size()];                for (int i = 0; i < colorAlgorithmNames.size(); i++)                    menuItems[i] = TrayController.createCheckbox(colorAlgorithmNames.get(i) + "", colorAlgorithmNames.get(i).equals(colorAlgorithm), null);                return menuItems;            };            Menu colalg = TrayController.createRadioGroup("Color Algorithm (" + colorAlgorithm + ")", colalgContentCreator.create(),                    (target, i, parent) -> {                        parent.setLabel("Color Algorithm (" + (colorAlgorithm = colorAlgorithmNames.get(i)) + ")");                        setActiveColorAlgorithm(colorAlgorithm);                    });            // Brightness            TrayController.CheckboxesCreator briContentCreator = () -> {                CheckboxMenuItem[] menuItems = new CheckboxMenuItem[5];                for (int i = 0; i < 5; i++)                    menuItems[i] = TrayController.createCheckbox((i + 1) * 20 + "%", (i + 1) * 20 == brightness, null);                return menuItems;            };            Menu bri = TrayController.createRadioGroup("Brightness (" + brightness + "%)", briContentCreator.create(),                    (target, i, parent) -> parent.setLabel("Brightness (" + (brightness = (i + 1) * 20) + "%)"));            return menuItems = new MenuItem[]{simcap, adpcap, capdel, setcaptoscr, colalg, bri};        };    }    public void loadPreferences() {        captureRadius = preferences.load("captureRadius", captureRadius);        captureArea.x = preferences.load("capturePosition.x", captureArea.x);        captureArea.y = preferences.load("capturePosition.y", captureArea.y);        captureArea.width = preferences.load("captureDimension.width", captureArea.width);        captureArea.height = preferences.load("captureDimension.height", captureArea.height);        simultaneousCapture = preferences.load("simultaneousCapture", simultaneousCapture);        adaptiveCapture = preferences.load("adaptiveCapture", adaptiveCapture);        captureDelay = preferences.load("captureDelay", captureDelay);        colorAlgorithm = preferences.load("colorAlgorithm", colorAlgorithm);        setActiveColorAlgorithm(colorAlgorithm);        brightness = preferences.load("brightness", brightness);        algorithmDefaultColorSuppress = preferences.load("colorAlgorithm.DEFAULT.colorSuppress", algorithmDefaultColorSuppress);        ColorAlgorithm.pixelIteration = preferences.load("colorAlgorithm.pixelIteration", ColorAlgorithm.pixelIteration);        ColorAlgorithm.pixelMinFadeStep = preferences.load("colorAlgorithm.pixelMinFadeStep", ColorAlgorithm.pixelMinFadeStep);        for (ColorAlgorithm algorithm : colorAlgorithms)            algorithm.loadPreferences(preferences);    }    public void savePreferences() {        preferences.save("captureRadius", captureRadius);        preferences.save("capturePosition.x", captureArea.x);        preferences.save("capturePosition.y", captureArea.y);        preferences.save("captureDimension.width", captureArea.width);        preferences.save("captureDimension.height", captureArea.height);        preferences.save("simultaneousCapture", simultaneousCapture);        preferences.save("adaptiveCapture", adaptiveCapture);        preferences.save("captureDelay", captureDelay);        preferences.save("colorAlgorithm", colorAlgorithm);        preferences.save("brightness", brightness);        preferences.save("colorAlgorithm.DEFAULT.colorSuppress", algorithmDefaultColorSuppress);        preferences.save("colorAlgorithm.pixelIteration", ColorAlgorithm.pixelIteration);        preferences.save("colorAlgorithm.pixelMinFadeStep", ColorAlgorithm.pixelMinFadeStep);        for (ColorAlgorithm algorithm : colorAlgorithms)            algorithm.savePreferences(preferences);    }    public void loadExtension(Class<Extension> extension) {        try {            ColorAlgorithm colorAlgorithm = (ColorAlgorithm) (extension).newInstance();            if (addColorAlgorithm(colorAlgorithm))                System.out.println("Successfully loaded color algorithm: " + colorAlgorithm.getName());        } catch (Exception e) {            System.err.println("ERROR(Ambilight):Failed to load extension of name " + extension.getSimpleName());        }    }    private boolean addColorAlgorithm(ColorAlgorithm newColorAlgorithm) {        if (!colorAlgorithmNames.contains(newColorAlgorithm.getName())) {            colorAlgorithmNames.add(newColorAlgorithm.getName());            colorAlgorithms.add(newColorAlgorithm);            return true;        }        else            System.err.println("ERROR(Ambilight): There is already a color algorithm under the name " + newColorAlgorithm.getName());        return false;    }    private void setActiveColorAlgorithm(String name) {        colorAlgorithm = colorAlgorithmNames.contains(name) ? name : colorAlgorithmNames.get(0);        currentColorAlgorithm = colorAlgorithms.get(colorAlgorithmNames.indexOf(colorAlgorithm));    }    private void capture(int side) {        side = lightHandler.getSideByIndex(side);        BufferedImage screenshot = robot.createScreenCapture(sides[side]);        try {            processCapture(side, screenshot);        } catch (Exception e) {            e.printStackTrace();        }        screenshot.flush();    }    private void fullCapture() {        for (int i = 0; i < sides.length; i++) {            capture(i);        }    }    private Rectangle detectBlackBars() {        int xPos = captureArea.width / 2 + captureArea.x - 10;        Rectangle bufferArea = new Rectangle(xPos, captureArea.y, 20, captureArea.height);        BufferedImage screenshot = robot.createScreenCapture(bufferArea);        int imgHeight = screenshot.getHeight();        int top = 0;        for (int y = 0; y < imgHeight / 2; y++) {            boolean rowIsBlack = true;            for (int x = 0; x < 20; x++) {                int pixel = screenshot.getRGB(x, y);                int r = (255 & (pixel >> 16));                int g = (255 & (pixel >> 8));                int b = (255 & (pixel));                if (!(r + g + b == 0)) {                    rowIsBlack = false;                    break;                }            }            if (rowIsBlack)                top = y;        }        return new Rectangle(captureArea.x, captureArea.y + top, captureArea.width, captureArea.height - top * 2);    }    private void processCapture(int side, BufferedImage screenshot) {        int lightsOnSide = lightHandler.numLightsOnSide(side);        int light = 0;        for (int i = 0; i < side; i++)            light += lightHandler.numLightsOnSide(i);        int[] rgb = new int[]{0, 0, 0};        int i = 0;        Rectangle rect = sides[side];        int stepX = (int) rect.getWidth() / lightsOnSide;        int stepY = (int) rect.getHeight() / lightsOnSide;        int[] avg = ColorAlgorithm.getAvgColor(screenshot, side, lightsOnSide, captureRadius, stepX, stepY);        while (i < lightsOnSide) {            rgb[0] = 0;            rgb[1] = 0;            rgb[2] = 0;            switch (side) {                case 0: // Left                    getAverage(captureRadius, step(lightsOnSide, i, stepY, true), captureRadius * 2, stepY, side, screenshot, avg, rgb);                    break;                case 1: // Top                    getAverage(step(lightsOnSide, i, stepX, !Global.lightLayoutClockwise), captureRadius, stepX, captureRadius * 2, side, screenshot, avg, rgb);                    break;                case 2: // Right                    getAverage(captureRadius, step(lightsOnSide, i, stepY, false), captureRadius * 2, stepY, side, screenshot, avg, rgb);                    break;                case 3: // Bottom                    getAverage(step(lightsOnSide, i, stepX, Global.lightLayoutClockwise), captureRadius, stepX, captureRadius * 2, side, screenshot, avg, rgb);                    break;                default:                    break;            }            ColorAlgorithm.forEachValue(rgb, (id) -> rgb[id] = (int) ((float) rgb[id] * (float) brightness / 100f));            if (lightHandler.addToUpdateBuffer(light, rgb[0], rgb[1], rgb[2]))                framesSinceLastUpdate = 0;            light += 1;            i += 1;        }    }    private int step(int height, int i, int step, boolean upward) {        if (upward)            return (height - i) * step - step / 2;        else            return i * step + step / 2;    }    private void getAverage(int px, int py, int pw, int ph, int side, BufferedImage image, int[] avg, int[] rgb) {        int xDir = 0;        int yDir = 0;        switch (side) {            case 0: // Right                xDir = -1;                yDir = 0;                break;            case 1: // Top                xDir = 0;                yDir = 1;                break;            case 2: // Left                xDir = 1;                yDir = 0;                break;            case 3: // Bottom                xDir = 0;                yDir = -1;                break;        }        currentColorAlgorithm.calculate(px, py, pw, ph, xDir, yDir, side, image, avg, rgb);    }    private void setCaptureRectangle(Point p, Dimension d, int r) {        setCaptureRectangle(p.x, p.y, d.width, d.height, r);    }    private void setCaptureRectangle(Rectangle a) {        setCaptureRectangle(a.x, a.y, a.width, a.height, captureRadius);    }    private void setCaptureRectangle(int x, int y, int w, int h, int r) {        captureArea.setLocation(x, y);        captureArea.setSize(w, h);        captureRadius = r;        for (int i = 0; i < lightHandler.numSides(); i++) {            switch (lightHandler.getSideByIndex(i)) {                case 3:                    sides[i] = new Rectangle(x, y + h - r * 2, w, r * 2);   // Bottom                    break;                case 2:                    sides[i] = new Rectangle(x, 0, r * 2, h);               // Left                    break;                case 1:                    sides[i] = new Rectangle(x, y, w, r * 2);               // Top                    break;                case 0:                    sides[i] = new Rectangle(x + w - r * 2, 0, r * 2, h);   // Right                    break;            }        }    }}