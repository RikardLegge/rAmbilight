package com.rambilight.plugins.Ambilight;import com.rambilight.core.api.Side;import com.rambilight.core.api.ui.TrayController;import com.rambilight.plugins.Ambilight.extensions.Classic;import com.rambilight.plugins.Ambilight.extensions.Default;import com.rambilight.plugins.Ambilight.extensions.SingleColor;import com.rambilight.plugins.Ambilight.extensions.SuppressDifferences;import com.rambilight.plugins.Module;import com.rambilight.plugins.extensions.Extension;import java.awt.*;import java.awt.event.ActionListener;import java.awt.image.BufferedImage;import java.util.ArrayList;import java.util.List;/** * A controller that uses screen capture to create an Ambilight feeling on the specified computer */public class Ambilight extends Module {	private Robot robot;	private static final int[] CAPTUREDELAYS = new int[]{1000, 500, 250, 100, 50, 25, 0};	// Default preferences	private Rectangle captureArea         = GraphicsEnvironment.getLocalGraphicsEnvironment().getScreenDevices()[0].getDefaultConfiguration().getBounds();	private String    colorAlgorithm      = "Default";	private int       captureRadius       = 64;	private int       captureDelay        = 50;	private int       brightness          = 60;	private boolean   simultaneousCapture = true;	private boolean   adaptiveCapture     = true;	// Timings	private int  framesSinceLastUpdate = 0;	private long lastStep              = 0;	// Cache	private Rectangle[] sides            = new Rectangle[0];	private int         currentRectangle = -1;	private FrameController changeCaptureRectangleFrameController;	MenuItem[] menuItems;	private List<String>         colorAlgorithmNames = new ArrayList<>();	private List<ColorAlgorithm> colorAlgorithms     = new ArrayList<>();	private ColorAlgorithm currentColorAlgorithm;	private TrayContent trayContent = new TrayContent();	public Ambilight() throws AWTException {		robot = new Robot();		addColorAlgorithm(new Default());		addColorAlgorithm(new SuppressDifferences());		addColorAlgorithm(new SingleColor());		addColorAlgorithm(new Classic());	}	public void loaded() {		sides = new Rectangle[lightHandler.numSides()];		setCaptureRectangle(captureArea);	}	public void suspend() {		if (changeCaptureRectangleFrameController != null)			changeCaptureRectangleFrameController.dispose();		changeCaptureRectangleFrameController = null;	}	public void step() {		int localCaptureDelay = -1;		boolean localSimultaneousCapture = simultaneousCapture;		if (adaptiveCapture)			if (framesSinceLastUpdate > 256)				localCaptureDelay = 1000;			else if (framesSinceLastUpdate > 128)				localCaptureDelay = 500;			else if (framesSinceLastUpdate > 64)				localCaptureDelay = 250;			else if (framesSinceLastUpdate > 32)				localCaptureDelay = 100;		if (localCaptureDelay < captureDelay)			localCaptureDelay = captureDelay;		else			localSimultaneousCapture = false;		framesSinceLastUpdate += 1;		if (localCaptureDelay > 0 && System.currentTimeMillis() - lastStep < localCaptureDelay)			return;		lastStep = System.currentTimeMillis();		if (localSimultaneousCapture)			fullCapture();		else			capture(currentRectangle = (currentRectangle + 1) % sides.length);	}	public void resume() {		boolean cache = simultaneousCapture;		simultaneousCapture = true;		step();		simultaneousCapture = cache;	}	public TrayController.CustomCreator getTrayCreator() {		return () -> {			CheckboxMenuItem simultaneousCaptureMenu = TrayController.createCheckbox("Simultaneous Capture", simultaneousCapture, (target, selected) -> simultaneousCapture = selected);			CheckboxMenuItem adaptiveCaptureMenu = TrayController.createCheckbox("Adaptive Capture", adaptiveCapture, (target, selected) -> adaptiveCapture = selected);			Menu captureDelayMenu = TrayController.createRadioGroup("Capture Delay (" + captureDelay + "ms)", trayContent.captureDelayCreator.create(), trayContent.captureDelayListener);			Menu captureAreaMenu = TrayController.createGroup("Set Capture Area", trayContent.captureAreaCreator.create(), trayContent.captureAreaListener);			captureAreaMenu.addActionListener(trayContent.captureAreaActionListener);			Menu colorAlgorithmMenu = TrayController.createRadioGroup("Color Algorithm (" + colorAlgorithm + ")", trayContent.colorAlgorithmCreator.create(), trayContent.colorAlgorithmListener);			Menu brightnessMenu = TrayController.createRadioGroup("Brightness (" + brightness + "%)", trayContent.brightnessCreator.create(), trayContent.brightnessListener);			return menuItems = new MenuItem[]{simultaneousCaptureMenu, adaptiveCaptureMenu, captureDelayMenu, captureAreaMenu, colorAlgorithmMenu, brightnessMenu};		};	}	public void loadPreferences() {		captureRadius = preferences.load("captureRadius", captureRadius);		captureArea.x = preferences.load("capturePosition.x", captureArea.x);		captureArea.y = preferences.load("capturePosition.y", captureArea.y);		captureArea.width = preferences.load("captureDimension.width", captureArea.width);		captureArea.height = preferences.load("captureDimension.height", captureArea.height);		simultaneousCapture = preferences.load("simultaneousCapture", simultaneousCapture);		adaptiveCapture = preferences.load("adaptiveCapture", adaptiveCapture);		captureDelay = preferences.load("captureDelay", captureDelay);		colorAlgorithm = preferences.load("colorAlgorithm", colorAlgorithm);		setActiveColorAlgorithm(colorAlgorithm);		brightness = preferences.load("brightness", brightness);		ColorAlgorithm.pixelIteration = preferences.load("colorAlgorithm.pixelIteration", ColorAlgorithm.pixelIteration);		ColorAlgorithm.pixelMinFadeStep = preferences.load("colorAlgorithm.pixelMinFadeStep", ColorAlgorithm.pixelMinFadeStep);		for (ColorAlgorithm algorithm : colorAlgorithms)			algorithm.loadPreferences(preferences);	}	public void savePreferences() {		preferences.save("captureRadius", captureRadius);		preferences.save("capturePosition.x", captureArea.x);		preferences.save("capturePosition.y", captureArea.y);		preferences.save("captureDimension.width", captureArea.width);		preferences.save("captureDimension.height", captureArea.height);		preferences.save("simultaneousCapture", simultaneousCapture);		preferences.save("adaptiveCapture", adaptiveCapture);		preferences.save("captureDelay", captureDelay);		preferences.save("colorAlgorithm", colorAlgorithm);		preferences.save("brightness", brightness);		preferences.save("colorAlgorithm.pixelIteration", ColorAlgorithm.pixelIteration);		preferences.save("colorAlgorithm.pixelMinFadeStep", ColorAlgorithm.pixelMinFadeStep);		for (ColorAlgorithm algorithm : colorAlgorithms)			algorithm.savePreferences(preferences);	}	public void loadExtension(Class<Extension> extension) {		try {			ColorAlgorithm colorAlgorithm = (ColorAlgorithm) (extension).newInstance();			if (addColorAlgorithm(colorAlgorithm))				System.out.println("Successfully loaded color algorithm: " + colorAlgorithm.getName());		} catch (Exception e) {			System.err.println("ERROR(Ambilight):Failed to load extension of name " + extension.getSimpleName());		}	}	private boolean addColorAlgorithm(ColorAlgorithm newColorAlgorithm) {		if (!colorAlgorithmNames.contains(newColorAlgorithm.getName())) {			colorAlgorithmNames.add(newColorAlgorithm.getName());			colorAlgorithms.add(newColorAlgorithm);			return true;		} else			System.err.println("ERROR(Ambilight): There is already a color algorithm under the name " + newColorAlgorithm.getName());		return false;	}	private void setActiveColorAlgorithm(String name) {		colorAlgorithm = colorAlgorithmNames.contains(name) ? name : colorAlgorithmNames.get(0);		currentColorAlgorithm = colorAlgorithms.get(colorAlgorithmNames.indexOf(colorAlgorithm));	}	private void capture(int side) {		if (sides[side] != null) {			BufferedImage screenshot = robot.createScreenCapture(sides[side]);			try {				processCapture(side, screenshot);			} catch (Exception e) {				e.printStackTrace();			}			screenshot.flush();		}	}	private void fullCapture() {		for (int i = 0; i < sides.length; i++) {			capture(i);		}	}	private Rectangle detectBlackBars() {		int xPos = captureArea.width / 2 + captureArea.x - 10;		Rectangle bufferArea = new Rectangle(xPos, captureArea.y, 20, captureArea.height / 3);		BufferedImage screenshot = robot.createScreenCapture(bufferArea);		int imgHeight = screenshot.getHeight();		int top = 0;		for (int y = 0; y < imgHeight; y++) {			boolean rowIsBlack = true;			for (int x = 0; x < 20; x++) {				int pixel = screenshot.getRGB(x, y);				int r = (255 & (pixel >> 16));				int g = (255 & (pixel >> 8));				int b = (255 & (pixel));				if (!(r + g + b == 0)) {					rowIsBlack = false;					break;				}			}			if (rowIsBlack)				top = y;		}		return new Rectangle(captureArea.x, captureArea.y + top, captureArea.width, captureArea.height - top * 2);	}	private void processCapture(int side, BufferedImage screenshot) {		int lightsOnSide = lightHandler.numLightsOnSide(side);		int light = 0;		for (int i = 0; i < side; i++)			light += lightHandler.numLightsOnSide(i);		int[] rgb = new int[]{0, 0, 0};		int i = 0;		Rectangle rect = sides[side];		int stepX = (int) rect.getWidth() / lightsOnSide;		int stepY = (int) rect.getHeight() / lightsOnSide;		int[] avg = ColorAlgorithm.getAvgColor(screenshot, side, lightsOnSide, captureRadius, stepX, stepY);		while (i < lightsOnSide) {			rgb[0] = 0;			rgb[1] = 0;			rgb[2] = 0;			switch (side) {				case Side.LEFT: // Left					getAverage(captureRadius, step(lightsOnSide, i, stepY, false), captureRadius * 2, stepY, side, screenshot, avg, rgb);					break;				case Side.TOP: // Top					getAverage(step(lightsOnSide, i, stepX, true), captureRadius, stepX, captureRadius * 2, side, screenshot, avg, rgb);					break;				case Side.RIGHT: // Right					getAverage(captureRadius, step(lightsOnSide, i, stepY, true), captureRadius * 2, stepY, side, screenshot, avg, rgb);					break;				case Side.BOTTOM: // Bottom					getAverage(step(lightsOnSide, i, stepX, false), captureRadius, stepX, captureRadius * 2, side, screenshot, avg, rgb);					break;				default:					break;			}			ColorAlgorithm.forEachValue(rgb, (id) -> rgb[id] = (int) ((float) rgb[id] * (float) brightness / 100f));			if (lightHandler.addToUpdateBuffer(light, rgb[0], rgb[1], rgb[2]))				framesSinceLastUpdate = 0;			light += 1;			i += 1;		}	}	private int step(int height, int i, int step, boolean upward) {		if (upward)			return (height - i) * step - step / 2;		else			return i * step + step / 2;	}	private void getAverage(int px, int py, int pw, int ph, int side, BufferedImage image, int[] avg, int[] rgb) {		int xDir = 0;		int yDir = 0;		switch (side) {			case Side.RIGHT: // Right				xDir = -1;				yDir = 0;				break;			case Side.TOP: // Top				xDir = 0;				yDir = 1;				break;			case Side.LEFT: // Left				xDir = 1;				yDir = 0;				break;			case Side.BOTTOM: // Bottom				xDir = 0;				yDir = -1;				break;		}		currentColorAlgorithm.calculate(px, py, pw, ph, xDir, yDir, side, image, avg, rgb);	}	private void setCaptureRectangle(Point p, Dimension d, int r) {		setCaptureRectangle(p.x, p.y, d.width, d.height, r);	}	private void setCaptureRectangle(Rectangle a) {		setCaptureRectangle(a.x, a.y, a.width, a.height, captureRadius);	}	private void setCaptureRectangle(int x, int y, int w, int h, int r) {		captureArea.setLocation(x, y);		captureArea.setSize(w, h);		captureRadius = r;		for (int side = 0; side < lightHandler.numSides(); side++) {			if (lightHandler.numLightsOnSide(side) > 0)    // TODO: Check if this really works for 0 length on specified side.				switch (side) {					case Side.BOTTOM:						sides[side] = new Rectangle(x, y + h - r * 2, w, r * 2);   // Bottom						break;					case Side.LEFT:						sides[side] = new Rectangle(x, 0, r * 2, h);               // Left						break;					case Side.TOP:						sides[side] = new Rectangle(x, y, w, r * 2);               // Top						break;					case Side.RIGHT:						sides[side] = new Rectangle(x + w - r * 2, 0, r * 2, h);   // Right						break;				}			else				sides[side] = null;		}	}	private class TrayContent {		TrayController.CheckboxesCreator captureDelayCreator = () -> {			CheckboxMenuItem[] menuItems = new CheckboxMenuItem[CAPTUREDELAYS.length];			for (int i = 0; i < CAPTUREDELAYS.length; i++)				menuItems[i] = TrayController.createCheckbox(CAPTUREDELAYS[i] + "ms", CAPTUREDELAYS[i] == captureDelay, null);			return menuItems;		};		TrayController.GroupStateChanged captureDelayListener = (target, i, parent) -> {			captureDelay = CAPTUREDELAYS[i];			parent.setLabel("Capture Delay (" + captureDelay + "ms)");		};		TrayController.CheckboxesCreator captureAreaCreator = () -> {			GraphicsDevice[] graphicsDevices = GraphicsEnvironment.getLocalGraphicsEnvironment().getScreenDevices();			CheckboxMenuItem[] menuItems = new CheckboxMenuItem[graphicsDevices.length + 2];			boolean sizeFound = false;			for (int i = 0; i < graphicsDevices.length; i++) {				menuItems[i] = TrayController.createCheckbox("Display " + i, false, null);				Rectangle bounds = graphicsDevices[i].getDefaultConfiguration().getBounds();				if (captureArea.getX() == bounds.getX() && captureArea.getY() == bounds.getY() && captureArea.getWidth() == bounds.getWidth() && captureArea.getHeight() == bounds.getHeight()) {					sizeFound = true;					menuItems[i].setState(true);				}			}			menuItems[graphicsDevices.length] = TrayController.createCheckbox("Custom", !sizeFound, (target, state) -> {				if (changeCaptureRectangleFrameController != null) {					target.setState(false);					return;				}				target.setLabel("[X] Cancel Selection");				target.setState(true);				changeCaptureRectangleFrameController = new FrameController(captureArea.getLocation(), captureArea.getSize(), captureRadius * 2,						(position, dimension, border) -> {							target.setLabel("Custom");							changeCaptureRectangleFrameController = null;							Menu parent = (Menu) target.getParent();							for (int i = 0; i < parent.getItemCount(); i++)								((CheckboxMenuItem) parent.getItem(i)).setState(false);							target.setState(true);							setCaptureRectangle(position, dimension, border / 2);						});			});			menuItems[graphicsDevices.length + 1] = TrayController.createCheckbox("Detect black bars", false, (target, state) -> {				Menu parent = (Menu) target.getParent();				for (int i = 0; i < parent.getItemCount(); i++)					((CheckboxMenuItem) parent.getItem(i)).setState(false);				target.setState(true);				Rectangle area = detectBlackBars();				setCaptureRectangle(area.getLocation(), area.getSize(), captureRadius);			});			return menuItems;		};		TrayController.GroupStateChanged captureAreaListener = (target, i, parent) -> {			if (changeCaptureRectangleFrameController != null) {				CheckboxMenuItem frameController = ((CheckboxMenuItem) parent.getItem(parent.getItemCount() - 2));				if (frameController.getState())					frameController.setState(false);				else {					parent.getItem(parent.getItemCount() - 2).setLabel("Custom");					changeCaptureRectangleFrameController.dispose();					changeCaptureRectangleFrameController = null;				}			}			GraphicsDevice[] graphicsDevices = GraphicsEnvironment.getLocalGraphicsEnvironment().getScreenDevices();			if (i < graphicsDevices.length) {				for (int j = 0; j < parent.getItemCount(); j++)					((CheckboxMenuItem) parent.getItem(j)).setState(false);				target.setState(true);				setCaptureRectangle(graphicsDevices[i].getDefaultConfiguration().getBounds());			}			// target.setState(false);		};		ActionListener captureAreaActionListener = (e) -> {			Menu menu = (Menu) e.getSource();			String markedName = "-1";			for (int i = 0; i < menu.getItemCount(); i++) {				CheckboxMenuItem child = (CheckboxMenuItem) menu.getItem(i);				if (child.getState()) {					markedName = child.getLabel();					child.setState(false);				}			}			((Menu) e.getSource()).removeAll();			CheckboxMenuItem[] contents = trayContent.captureAreaCreator.create();			for (CheckboxMenuItem item : contents) {				TrayController.addToGroup(menu, item, trayContent.captureAreaListener);				if (item.getLabel().equals(markedName))					item.setState(true);			}		};		TrayController.CheckboxesCreator colorAlgorithmCreator = () -> {			CheckboxMenuItem[] menuItems = new CheckboxMenuItem[colorAlgorithmNames.size()];			for (int i = 0; i < colorAlgorithmNames.size(); i++)				menuItems[i] = TrayController.createCheckbox(colorAlgorithmNames.get(i) + "", colorAlgorithmNames.get(i).equals(colorAlgorithm), null);			return menuItems;		};		TrayController.GroupStateChanged colorAlgorithmListener = (target, i, parent) -> {			parent.setLabel("Color Algorithm (" + (colorAlgorithm = colorAlgorithmNames.get(i)) + ")");			setActiveColorAlgorithm(colorAlgorithm);		};		TrayController.CheckboxesCreator brightnessCreator = () -> {			CheckboxMenuItem[] menuItems = new CheckboxMenuItem[5];			for (int i = 0; i < 5; i++)				menuItems[i] = TrayController.createCheckbox((i + 1) * 20 + "%", (i + 1) * 20 == brightness, null);			return menuItems;		};		TrayController.GroupStateChanged brightnessListener = (target, i, parent) -> {			parent.setLabel("Brightness (" + (brightness = (i + 1) * 20) + "%)");		};	}}