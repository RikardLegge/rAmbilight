package com.rambilight.plugins.Ambilight;import com.rambilight.core.api.Global;import com.rambilight.core.api.ui.TrayController;import com.rambilight.plugins.Module;import java.awt.*;import java.awt.image.BufferedImage;/** * A controller that uses screen capture to create an Ambilight feeling on the specified computer */public class Ambilight extends Module {    private Robot robot;    private static final String[] COLORALGORITMNAMES = new String[]{"Off", "Dark room", "Default", "Classic", "Dim White", "Single color"};    private static final int[]    CAPTUREDELAYS      = new int[]{1000, 500, 250, 100, 50, 25, 0};    // Default preferences    private Rectangle captureArea                   = GraphicsEnvironment.getLocalGraphicsEnvironment().getScreenDevices()[0].getDefaultConfiguration().getBounds();    private int       captureRadius                 = 64;    private int       captureDelay                  = 50;    private int       colorAlgorithm                = 2;    private int       brightness                    = 60;    private int       algorithmDefaultColorSuppress = 3;    private boolean   simultaneousCapture           = true;    private boolean   adaptiveCapture               = true;    // Timings    private int  framesSinceLastUpdate = 0;    private long lastStep              = 0;    // Cache    private Rectangle[] sides            = new Rectangle[0];    private int         currentRectangle = -1;    private FrameController changeCaptureRectangleFrameController;    MenuItem[] menuItems;    public Ambilight() throws AWTException {        robot = new Robot();    }    public void loaded() {        sides = new Rectangle[lightHandler.numSides()];        setCaptureRectangle(captureArea);    }    public void suspend() {        if (changeCaptureRectangleFrameController != null)            changeCaptureRectangleFrameController.dispose();        changeCaptureRectangleFrameController = null;    }    public void step() {        int localCaptureDelay = -1;        boolean localSimultaneousCapture = simultaneousCapture;        if (adaptiveCapture)            if (framesSinceLastUpdate > 256)                localCaptureDelay = 1000;            else if (framesSinceLastUpdate > 128)                localCaptureDelay = 500;            else if (framesSinceLastUpdate > 64)                localCaptureDelay = 250;            else if (framesSinceLastUpdate > 32)                localCaptureDelay = 100;        if (localCaptureDelay < captureDelay)            localCaptureDelay = captureDelay;        else            localSimultaneousCapture = false;        framesSinceLastUpdate += 1;        if (localCaptureDelay > 0 && System.currentTimeMillis() - lastStep < localCaptureDelay)            return;        lastStep = System.currentTimeMillis();        if (localSimultaneousCapture)            fullCapture();        else            capture(currentRectangle = (currentRectangle + 1) % sides.length);    }    public void resume() {        boolean cache = simultaneousCapture;        simultaneousCapture = true;        step();        simultaneousCapture = cache;    }    public TrayController.CustomCreator getTrayCreator() {        return () -> {            // Simultaneous capture            CheckboxMenuItem simcap = TrayController.createCheckbox("Simultaneous Capture", simultaneousCapture, (target, selected) -> simultaneousCapture = selected);            // Adaptive capture            CheckboxMenuItem adpcap = TrayController.createCheckbox("Adaptive Capture", adaptiveCapture, (target, selected) -> adaptiveCapture = selected);            // Capture Delay            TrayController.CheckboxesCreator capdelContentCreator = () -> {                CheckboxMenuItem[] menuItems = new CheckboxMenuItem[CAPTUREDELAYS.length];                for (int i = 0; i < CAPTUREDELAYS.length; i++)                    menuItems[i] = TrayController.createCheckbox(CAPTUREDELAYS[i] + "ms", CAPTUREDELAYS[i] == captureDelay, null);                return menuItems;            };            Menu capdel = TrayController.createRadioGroup("Capture Delay (" + captureDelay + "ms)", capdelContentCreator.create(), (target, i, parent) -> {                captureDelay = CAPTUREDELAYS[i];                parent.setLabel("Capture Delay (" + captureDelay + "ms)");            });            // Capture area            TrayController.CheckboxesCreator setcaptoscrContentCreator = () -> {                GraphicsDevice[] graphicsDevices = GraphicsEnvironment.getLocalGraphicsEnvironment().getScreenDevices();                CheckboxMenuItem[] menuItems = new CheckboxMenuItem[graphicsDevices.length + 1];                boolean sizeFound = false;                for (int i = 0; i < graphicsDevices.length; i++) {                    menuItems[i] = TrayController.createCheckbox("Display " + i, false, null);                    Rectangle bounds = graphicsDevices[i].getDefaultConfiguration().getBounds();                    if (captureArea.getX() == bounds.getX() && captureArea.getY() == bounds.getY() && captureArea.getWidth() == bounds.getWidth() && captureArea.getHeight() == bounds.getHeight()) {                        sizeFound = true;                        menuItems[i].setState(true);                    }                }                menuItems[graphicsDevices.length] = TrayController.createCheckbox("Custom", !sizeFound, (target, state) -> {                    if (changeCaptureRectangleFrameController != null) {                        target.setState(false);                        return;                    }                    target.setLabel("[X] Cancel Selection");                    target.setState(true);                    changeCaptureRectangleFrameController = new FrameController(captureArea.getLocation(), captureArea.getSize(), captureRadius * 2,                            (position, dimension, border) -> {                                target.setLabel("Custom");                                changeCaptureRectangleFrameController = null;                                Menu parent = (Menu) target.getParent();                                for (int i = 0; i < parent.getItemCount(); i++)                                    ((CheckboxMenuItem) parent.getItem(i)).setState(false);                                target.setState(true);                                setCaptureRectangle(position, dimension, border / 2);                            });                });                return menuItems;            };            TrayController.GroupStateChanged setcaptoscrListener = (target, i, parent) -> {                if (changeCaptureRectangleFrameController != null) {                    CheckboxMenuItem frameController = ((CheckboxMenuItem) parent.getItem(parent.getItemCount() - 1));                    if (frameController.getState())                        frameController.setState(false);                    else {                        parent.getItem(parent.getItemCount() - 1).setLabel("Custom");                        changeCaptureRectangleFrameController.dispose();                        changeCaptureRectangleFrameController = null;                    }                }                GraphicsDevice[] graphicsDevices = GraphicsEnvironment.getLocalGraphicsEnvironment().getScreenDevices();                if (i < graphicsDevices.length) {                    for (int j = 0; j < parent.getItemCount(); j++)                        ((CheckboxMenuItem) parent.getItem(j)).setState(false);                    target.setState(true);                    setCaptureRectangle(graphicsDevices[i].getDefaultConfiguration().getBounds());                }                // target.setState(false);            };            Menu setcaptoscr = TrayController.createGroup("Set Capture Area", setcaptoscrContentCreator.create(), setcaptoscrListener);            setcaptoscr.addActionListener((e) -> {                String markedName = "-1";                for (int i = 0; i < setcaptoscr.getItemCount(); i++) {                    CheckboxMenuItem child = (CheckboxMenuItem) setcaptoscr.getItem(i);                    if (child.getState()) {                        markedName = child.getLabel();                        child.setState(false);                    }                }                ((Menu) e.getSource()).removeAll();                CheckboxMenuItem[] contents = setcaptoscrContentCreator.create();                for (CheckboxMenuItem item : contents) {                    TrayController.addToGroup(setcaptoscr, item, setcaptoscrListener);                    if (item.getLabel().equals(markedName))                        item.setState(true);                }            });            // Color Algorithm            TrayController.CheckboxesCreator colalgContentCreator = () -> {                CheckboxMenuItem[] menuItems = new CheckboxMenuItem[COLORALGORITMNAMES.length];                for (int i = 0; i < COLORALGORITMNAMES.length; i++)                    menuItems[i] = TrayController.createCheckbox(COLORALGORITMNAMES[i] + "", i == colorAlgorithm, null);                return menuItems;            };            Menu colalg = TrayController.createRadioGroup("Color Algorithm (" + COLORALGORITMNAMES[colorAlgorithm] + ")", colalgContentCreator.create(),                    (target, i, parent) -> parent.setLabel("Color Algorithm (" + COLORALGORITMNAMES[colorAlgorithm = i] + ")"));            // Brightness            TrayController.CheckboxesCreator briContentCreator = () -> {                CheckboxMenuItem[] menuItems = new CheckboxMenuItem[5];                for (int i = 0; i < 5; i++)                    menuItems[i] = TrayController.createCheckbox((i + 1) * 20 + "%", (i + 1) * 20 == brightness, null);                return menuItems;            };            Menu bri = TrayController.createRadioGroup("Brightness (" + brightness + "%)", briContentCreator.create(),                    (target, i, parent) -> parent.setLabel("Brightness (" + (brightness = (i + 1) * 20) + "%)"));            return menuItems = new MenuItem[]{simcap, adpcap, capdel, setcaptoscr, colalg, bri};        };    }    public void loadPreferences() {        captureRadius = preferences.load("captureRadius", captureRadius);        captureArea.x = preferences.load("capturePosition.x", captureArea.x);        captureArea.y = preferences.load("capturePosition.y", captureArea.y);        captureArea.width = preferences.load("captureDimension.width", captureArea.width);        captureArea.height = preferences.load("captureDimension.height", captureArea.height);        simultaneousCapture = preferences.load("simultaneousCapture", simultaneousCapture);        adaptiveCapture = preferences.load("adaptiveCapture", adaptiveCapture);        captureDelay = preferences.load("captureDelay", captureDelay);        colorAlgorithm = preferences.load("colorAlgorithm", colorAlgorithm) > COLORALGORITMNAMES.length - 1 ? colorAlgorithm : preferences.load("colorAlgorithm", colorAlgorithm);        brightness = preferences.load("brightness", brightness);        algorithmDefaultColorSuppress = preferences.load("colorAlgorithm.DEFAULT.colorSuppress", algorithmDefaultColorSuppress);        ColAlg.pixelIteration = preferences.load("colorAlgorithm.pixelIteration", ColAlg.pixelIteration);        ColAlg.pixelMinFadeStep = preferences.load("colorAlgorithm.pixelMinFadeStep", ColAlg.pixelMinFadeStep);    }    public void savePreferences() {        preferences.save("captureRadius", captureRadius);        preferences.save("capturePosition.x", captureArea.x);        preferences.save("capturePosition.y", captureArea.y);        preferences.save("captureDimension.width", captureArea.width);        preferences.save("captureDimension.height", captureArea.height);        preferences.save("simultaneousCapture", simultaneousCapture);        preferences.save("adaptiveCapture", adaptiveCapture);        preferences.save("captureDelay", captureDelay);        preferences.save("colorAlgorithm", colorAlgorithm);        preferences.save("brightness", brightness);        preferences.save("colorAlgorithm.DEFAULT.colorSuppress", algorithmDefaultColorSuppress);        preferences.save("colorAlgorithm.pixelIteration", ColAlg.pixelIteration);        preferences.save("colorAlgorithm.pixelMinFadeStep", ColAlg.pixelMinFadeStep);    }    private void capture(int side) {        side = lightHandler.getSideByIndex(side);        BufferedImage screenshot = robot.createScreenCapture(sides[side]);        processCapture(side, screenshot);        screenshot.flush();    }    private void fullCapture() {        for (int i = 0; i < sides.length; i++) {            capture(i);        }    }    private void processCapture(int side, BufferedImage screenshot) {        int lightsOnSide = lightHandler.numLightsOnSide(side);        int light = 0;        for (int i = 0; i < side; i++)            light += lightHandler.numLightsOnSide(i);        int[] rgb = new int[]{0, 0, 0};        int i = 0;        Rectangle rect = sides[side];        int stepX = (int) rect.getWidth() / lightsOnSide;        int stepY = (int) rect.getHeight() / lightsOnSide;        int[] avg = ColAlg.getAvgColor(screenshot, side, lightsOnSide, captureRadius, stepX, stepY);        while (i < lightsOnSide) {            rgb[0] = 0;            rgb[1] = 0;            rgb[2] = 0;            switch (side) {                case 0: // Left                    getAverage(captureRadius, step(lightsOnSide, i, stepY, true), captureRadius * 2, stepY, side, screenshot, avg, rgb);                    break;                case 1: // Top                    getAverage(step(lightsOnSide, i, stepX, !Global.lightLayoutClockwise), captureRadius, stepX, captureRadius * 2, side, screenshot, avg, rgb);                    break;                case 2: // Right                    getAverage(captureRadius, step(lightsOnSide, i, stepY, false), captureRadius * 2, stepY, side, screenshot, avg, rgb);                    break;                case 3: // Bottom                    getAverage(step(lightsOnSide, i, stepX, Global.lightLayoutClockwise), captureRadius, stepX, captureRadius * 2, side, screenshot, avg, rgb);                    break;                default:                    break;            }            ColAlg.forEachValue(rgb, (id) -> rgb[id] = (int) ((float) rgb[id] * (float) brightness / 100f));            if (lightHandler.addToUpdateBuffer(light, rgb[0], rgb[1], rgb[2]))                framesSinceLastUpdate = 0;            light += 1;            i += 1;        }    }    private int step(int height, int i, int step, boolean upward) {        if (upward)            return (height - i) * step - step / 2;        else            return i * step + step / 2;    }    private void getAverage(int px, int py, int pw, int ph, int side, BufferedImage image, int[] avg, int[] rgb) {        int itt;        int brightness;        int xDir = 0;        int yDir = 0;        switch (side) {            case 0: // Right                xDir = -1;                yDir = 0;                break;            case 1: // Top                xDir = 0;                yDir = 1;                break;            case 2: // Left                xDir = 1;                yDir = 0;                break;            case 3: // Bottom                xDir = 0;                yDir = -1;                break;        }        switch (colorAlgorithm) {            case 1:                itt = ColAlg.forEachPixel(px, py, pw, ph, xDir, yDir, image, (pixel) -> ColAlg.add(pixel, rgb));                brightness = ColAlg.getBrightness(avg);                ColAlg.avg(itt, rgb);                ColAlg.pow(brightness, brightness, 2f, rgb);                ColAlg.normalize(rgb);                rgb[0] *= .4;                rgb[1] *= .4;                rgb[2] *= .4;                break;            case 2:                // Get color related to the current area.                itt = ColAlg.forEachPixel(px, py, pw, ph, xDir, yDir, image, (pixel) -> ColAlg.add(pixel, rgb));                brightness = ColAlg.getBrightness(avg);                ColAlg.avg(itt, rgb);                // Blend it with the average.                rgb[0] = (avg[0] * algorithmDefaultColorSuppress + rgb[0]) / (algorithmDefaultColorSuppress + 1);                rgb[1] = (avg[1] * algorithmDefaultColorSuppress + rgb[1]) / (algorithmDefaultColorSuppress + 1);                rgb[2] = (avg[2] * algorithmDefaultColorSuppress + rgb[2]) / (algorithmDefaultColorSuppress + 1);                ColAlg.pow(brightness, brightness, 2f, rgb);                ColAlg.normalize(rgb);                // Get the maximum difference of the color channels.                int diff = 0;                for (int i = 0; i < 3; i++) {                    int tmpDiff = ColAlg.diff(rgb[i], rgb[(i + 1) % 3]);                    diff = diff > tmpDiff ? diff : tmpDiff;                }                // Dim the white channel.                if (diff <= 20)                    for (int i = 0; i < 3; i++)                        rgb[i] *= Math.pow((diff / 3f + 13f) / 20f, 2f);                break;            case 3:                itt = ColAlg.forEachPixel(px, py, pw, ph, xDir, yDir, image, (pixel) -> ColAlg.add(pixel, rgb));                brightness = ColAlg.getBrightness(avg);                ColAlg.avg(itt, rgb);                ColAlg.pow(brightness, brightness, 2f, rgb);                ColAlg.normalize(rgb);                break;            case 4:                itt = ColAlg.forEachPixel(px, py, pw, ph, xDir, yDir, image, (pixel) -> ColAlg.add(pixel, rgb));                brightness = ColAlg.getBrightness(avg);                ColAlg.avg(itt, rgb);                ColAlg.pow(brightness, brightness, 2f, rgb);                ColAlg.normalize(rgb);                diff = 0;                for (int i = 0; i < 3; i++) {                    int tmpDiff = ColAlg.diff(rgb[i], rgb[(i + 1) % 3]);                    diff = diff > tmpDiff ? diff : tmpDiff;                }                if (diff <= 40)                    for (int i = 0; i < 3; i++)                        rgb[i] *= Math.pow((diff / 3f + 26f) / 40f, 2f);                break;            case 5:                brightness = ColAlg.getBrightness(avg);                rgb[0] = avg[0];                rgb[1] = avg[1];                rgb[2] = avg[2];                ColAlg.pow(brightness, brightness, 2f, rgb);                ColAlg.normalize(rgb);                break;            default:                break;        }        ColAlg.limit(252, rgb);    }    private void setCaptureRectangle(Point p, Dimension d, int r) {        setCaptureRectangle(p.x, p.y, d.width, d.height, r);    }    private void setCaptureRectangle(Rectangle a) {        setCaptureRectangle(a.x, a.y, a.width, a.height, captureRadius);    }    private void setCaptureRectangle(int x, int y, int w, int h, int r) {        captureArea.setLocation(x, y);        captureArea.setSize(w, h);        captureRadius = r;        for (int i = 0; i < lightHandler.numSides(); i++) {            switch (lightHandler.getSideByIndex(i)) {                case 3:                    sides[i] = new Rectangle(x, y + h - r * 2, w, r * 2);   // Bottom                    break;                case 2:                    sides[i] = new Rectangle(x, 0, r * 2, h);               // Left                    break;                case 1:                    sides[i] = new Rectangle(x, y, w, r * 2);               // Top                    break;                case 0:                    sides[i] = new Rectangle(x + w - r * 2, 0, r * 2, h);   // Right                    break;            }        }    }}