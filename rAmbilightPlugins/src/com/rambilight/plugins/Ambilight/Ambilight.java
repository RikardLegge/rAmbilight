package com.rambilight.plugins.Ambilight;import com.rambilight.core.Global;import com.rambilight.core.ui.TrayController;import com.rambilight.core.ui.TrayController.CustomCreator;import com.rambilight.plugins.Module;import java.awt.*;import java.awt.image.BufferedImage;/** * A controller that uses screen capture to create an Ambilight feeling on the specified computer */public class Ambilight extends Module {    private Robot robot;    private static final String[] COLORALGORITMNAMES = new String[]{"Off", "Dark room", "Default", "Classic", "Dim White", "Single color"};    private static final int[]    CAPTUREDELAYS      = new int[]{1000, 500, 250, 100, 50, 25, 0};    // Default preferences    private Rectangle captureArea         = GraphicsEnvironment.getLocalGraphicsEnvironment().getMaximumWindowBounds();    private int       captureRadius       = 24;    private int       captureDelay        = 50;    private int       colorAlgorithm      = 2;    private int       brightness          = 60;    private boolean   simultaneousCapture = true;    private boolean   adaptiveCapture     = true;    // Timings    private int  framesSinceLastUpdate = 0;    private long lastStep              = 0;    // Cache    private Rectangle[] sides            = new Rectangle[0];    private int         currentRectangle = -1;    private FrameController changeCaptureRectangleFrameController;    MenuItem[] menuItems;    public Ambilight() throws AWTException {        sides = new Rectangle[Global.lightLayout.length];        robot = new Robot();    }    public void loaded() {        setCaptureRectangle(captureArea);    }    public void suspend() {        if (menuItems.length > 2) {            menuItems[2].setLabel("Change capture rectangle");            if (changeCaptureRectangleFrameController != null)                changeCaptureRectangleFrameController.dispose();            changeCaptureRectangleFrameController = null;        }    }    public void step() {        int localCaptureDelay;        if (adaptiveCapture && framesSinceLastUpdate > 50)            localCaptureDelay = 1000;        else if (adaptiveCapture && framesSinceLastUpdate > 30)            localCaptureDelay = 500;        else if (adaptiveCapture && framesSinceLastUpdate > 20)            localCaptureDelay = 250;        else if (adaptiveCapture && framesSinceLastUpdate > 10)            localCaptureDelay = 100;        else            localCaptureDelay = captureDelay;        if (localCaptureDelay < captureDelay)            localCaptureDelay = captureDelay;        if (localCaptureDelay > 0 && System.currentTimeMillis() - lastStep < localCaptureDelay)            return;        lastStep = System.currentTimeMillis();        if (simultaneousCapture)            fullCapture();        else            capture(currentRectangle = (currentRectangle + 1) % sides.length);    }    public void resume() {        boolean cache = simultaneousCapture;        simultaneousCapture = true;        step();        simultaneousCapture = cache;    }    public CustomCreator getTrayCreator() {        return () -> {            // Temporary object holding the list items            CheckboxMenuItem[] tmpItems;            // Simultaneous capture            CheckboxMenuItem simcap = TrayController.createCheckbox("Simultaneous capture", simultaneousCapture, (target, selected) -> simultaneousCapture = selected);            // Adaptive capture            CheckboxMenuItem adpcap = TrayController.createCheckbox("Adaptive capture", adaptiveCapture, (target, selected) -> adaptiveCapture = selected);            // Capture Delay            tmpItems = new CheckboxMenuItem[CAPTUREDELAYS.length];            for (int i = 0; i < CAPTUREDELAYS.length; i++)                tmpItems[i] = TrayController.createCheckbox(CAPTUREDELAYS[i] + "ms", CAPTUREDELAYS[i] == captureDelay, null);            Menu capdel = TrayController.createRadioGroup("Capture delay (" + captureDelay + "ms)", tmpItems, (target, i, parent) -> {                captureDelay = CAPTUREDELAYS[i];                parent.setLabel("Capture delay (" + captureDelay + "ms)");            });            // Change capture rectangle            MenuItem chacaprec = TrayController.createItem("Change capture rectangle", (target) -> {                if (target.getLabel().contains("[X]")) {                    target.setLabel("Change capture rectangle");                    changeCaptureRectangleFrameController.dispose();                    changeCaptureRectangleFrameController = null;                    return;                }                target.setLabel("[X] Cancel change");                changeCaptureRectangleFrameController = new FrameController(captureArea.getLocation(), captureArea.getSize(), captureRadius * 2,                        (position, dimension, border) -> {                            target.setLabel("Change capture rectangle");                            changeCaptureRectangleFrameController = null;                            setCaptureRectangle(position, dimension, border / 2);                        });            });            // Reset capture rectangle            MenuItem rescaprec = TrayController.createItem("Reset capture rectangle", (target) -> {                captureArea.setBounds(GraphicsEnvironment.getLocalGraphicsEnvironment().getMaximumWindowBounds());                setCaptureRectangle(captureArea.getLocation(), captureArea.getSize(), 24);            });            // Color Algorithm            tmpItems = new CheckboxMenuItem[COLORALGORITMNAMES.length];            for (int i = 0; i < COLORALGORITMNAMES.length; i++)                tmpItems[i] = TrayController.createCheckbox(COLORALGORITMNAMES[i] + "", i == colorAlgorithm, null);            Menu colalg = TrayController.createRadioGroup("Color Algorithm (" + COLORALGORITMNAMES[colorAlgorithm] + ")", tmpItems,                    (target, i, parent) -> parent.setLabel("Color Algorithm (" + COLORALGORITMNAMES[colorAlgorithm = i] + ")"));            // Brightness            tmpItems = new CheckboxMenuItem[5];            for (int i = 0; i < 5; i++)                tmpItems[i] = TrayController.createCheckbox((i + 1) * 20 + "%", (i + 1) * 20 == brightness, null);            Menu bri = TrayController.createRadioGroup("Brightness (" + brightness + "%)", tmpItems,                    (target, i, parent) -> parent.setLabel("Brightness (" + (brightness = (i + 1) * 20) + "%)"));            return menuItems = new MenuItem[]{simcap, adpcap, capdel, chacaprec, rescaprec, colalg, bri};        };    }    public void loadPreferences() {        captureRadius = preferences.load("captureRadius", captureRadius);        captureArea.x = preferences.load("capturePosition.x", captureArea.x);        captureArea.y = preferences.load("capturePosition.y", captureArea.y);        captureArea.width = preferences.load("captureDimension.width", captureArea.width);        captureArea.height = preferences.load("captureDimension.height", captureArea.height);        simultaneousCapture = preferences.load("simultaneousCapture", simultaneousCapture);        adaptiveCapture = preferences.load("adaptiveCapture", adaptiveCapture);        captureDelay = preferences.load("captureDelay", captureDelay);        colorAlgorithm = preferences.load("colorAlgorithm", colorAlgorithm) > COLORALGORITMNAMES.length - 1 ? colorAlgorithm : preferences.load("colorAlgorithm", colorAlgorithm);        brightness = preferences.load("brightness", brightness);    }    public void savePreferences() {        preferences.save("captureRadius", captureRadius);        preferences.save("capturePosition.x", captureArea.x);        preferences.save("capturePosition.y", captureArea.y);        preferences.save("captureDimension.width", captureArea.width);        preferences.save("captureDimension.height", captureArea.height);        preferences.save("simultaneousCapture", simultaneousCapture);        preferences.save("adaptiveCapture", adaptiveCapture);        preferences.save("captureDelay", captureDelay);        preferences.save("colorAlgorithm", colorAlgorithm);        preferences.save("brightness", brightness);    }    /**     * Capture a single side of the capture area     */    private void capture(int side) {        BufferedImage screenshot = robot.createScreenCapture(sides[side]);        processCapture(side, screenshot);        screenshot.flush();    }    /**     * Capture all the side of the capture area at once     */    private void fullCapture() {        for (int i = 0; i < sides.length; i++) {            capture(i);        }    }    /**     * Processes the captured image and adds the new pixel values to the LightHandler     */    private void processCapture(int side, BufferedImage screenshot) {        framesSinceLastUpdate++;        int light = 0;        for (int i = 0; i < side; i++)            light += Global.lightLayout[i];        int[] rgb = new int[]{0, 0, 0};        int i = 0;        Rectangle rect = sides[side];        int stepX = (int) rect.getWidth() / Global.lightLayout[side];        int stepY = (int) rect.getHeight() / Global.lightLayout[side];        int[] avg = ColAlg.getAvgColor(screenshot, side, Global.lightLayout[side], captureRadius, stepX, stepY);        while (i < Global.lightLayout[side]) {            rgb[0] = 0;            rgb[1] = 0;            rgb[2] = 0;            switch (side) {                case 0: // Right                    getAverage(captureRadius, (Global.lightLayout[side] - i) * stepY - stepY / 2, captureRadius * 2, stepY, side, screenshot, avg, rgb);                    break;                case 1: // Top                    getAverage((Global.lightLayout[side] - i) * stepX - stepX / 2, captureRadius, stepX, captureRadius * 2, side, screenshot, avg, rgb);                    break;                case 2: // Left                    getAverage(screenshot.getWidth() - captureRadius, i * stepY + stepY / 2, captureRadius * 2, stepY, side, screenshot, avg, rgb);                    break;                case 3: // Bottom                    getAverage(i * stepX + stepX / 2, screenshot.getHeight() - captureRadius, stepX, captureRadius * 2, side, screenshot, avg, rgb);                    break;                default:                    break;            }            ColAlg.forEachValue(rgb, (id) -> rgb[id] = (int) ((float) rgb[id] * (float) brightness / 100f));            if (lightHandler.addToUpdateBuffer(light, rgb[0], rgb[1], rgb[2]))                framesSinceLastUpdate = 0;            light += 1;            i += 1;        }    }    /**     * The function that gets the average color for each light     */    private void getAverage(int px, int py, int pw, int ph, int side, BufferedImage image, int[] avg, int[] rgb) {        int itt;        int brightness;        int xDir = 0;        int yDir = 0;        switch (side) {            case 0: // Right                xDir = -1;                yDir = 0;                break;            case 1: // Top                xDir = 0;                yDir = 1;                break;            case 2: // Left                xDir = 1;                yDir = 0;                break;            case 3: // Bottom                xDir = 0;                yDir = -1;                break;        }        switch (colorAlgorithm) {            case 1:                itt = ColAlg.forEachPixel(px, py, pw, ph, xDir, yDir, image, (pixel) -> ColAlg.add(pixel, rgb));                brightness = ColAlg.getBrightness(avg);                ColAlg.avg(itt, rgb);                ColAlg.pow(brightness, brightness, 2f, rgb);                ColAlg.normalize(rgb);                rgb[0] *= .4;                rgb[1] *= .4;                rgb[2] *= .4;                break;            case 2:                itt = ColAlg.forEachPixel(px, py, pw, ph, xDir, yDir, image, (pixel) -> ColAlg.add(pixel, rgb));                brightness = ColAlg.getBrightness(avg);                ColAlg.avg(itt, rgb);                ColAlg.pow(brightness, brightness, 2f, rgb);                ColAlg.normalize(rgb);                break;            case 3:                itt = ColAlg.forEachPixel(px, py, pw, ph, xDir, yDir, image, (pixel) -> ColAlg.add(pixel, rgb));                ColAlg.avg(itt, rgb);                rgb[0] *= .9;                rgb[1] *= 1.1;                rgb[2] *= 1.0;                ColAlg.normalize(rgb);                break;            case 4:                itt = ColAlg.forEachPixel(px, py, pw, ph, xDir, yDir, image, (pixel) -> ColAlg.add(pixel, rgb));                brightness = ColAlg.getBrightness(avg);                ColAlg.avg(itt, rgb);                //System.out.println(rgb[0] + ":" + rgb[1] + ":" + rgb[2]);                ColAlg.pow(brightness, brightness, 2f, rgb);                ColAlg.normalize(rgb);                int diff = 0;                for (int i = 0; i < 3; i++) {                    int tmpDiff = ColAlg.diff(rgb[i], rgb[(i + 1) % 3]);                    diff = diff > tmpDiff ? diff : tmpDiff;                }                if (diff <= 40)                    for (int i = 0; i < 3; i++)                        rgb[i] *= Math.pow((diff / 3f + 26f) / 40f, 2f);                break;            case 5:                brightness = ColAlg.getBrightness(avg);                rgb[0] = avg[0];                rgb[1] = avg[1];                rgb[2] = avg[2];                ColAlg.pow(brightness, brightness, 2f, rgb);                ColAlg.normalize(rgb);                break;            default:                break;        }        ColAlg.limit(252, rgb);    }    /**     * Sets the capture area of the screen capture     */    private void setCaptureRectangle(Point p, Dimension d, int r) {        setCaptureRectangle(p.x, p.y, d.width, d.height, r);    }    private void setCaptureRectangle(Rectangle a) {        setCaptureRectangle(a.x, a.y, a.width, a.height, captureRadius);    }    private void setCaptureRectangle(int x, int y, int w, int h, int r) {        captureArea.setLocation(x, y);        captureArea.setSize(w, h);        captureRadius = r;        if (Global.lightLayout.length > 0)            sides[0] = new Rectangle(x + w - r * 2, 0, r * 2, h);   // Right        if (Global.lightLayout.length > 1)            sides[1] = new Rectangle(x, y, w, r * 2);               // Top        if (Global.lightLayout.length > 2)            sides[2] = new Rectangle(x, 0, r * 2, h);               // Left        if (Global.lightLayout.length > 3)            sides[3] = new Rectangle(x, y + h - r * 2, w, r * 2);   // Bottom    }}/** * Class that holds all parts of my color Algorithms */class ColAlg {    public static void pow(float div, float mult, float pow, int[] rgb) {        for (int i = 0; i < rgb.length; i++)            rgb[i] = Math.round(((float) Math.pow((float) rgb[i] / div, pow)) * mult);    }    public static void normalize(int[] rgb) {        int strong = getStrongest(rgb);        int normal = Math.max(1, rgb[strong] / 255);        forEachValue(rgb, (i) -> {            rgb[i] *= normal;        });    }    public static void limit(int limit, int[] rgb) {        for (int i = 0; i < rgb.length; i++)            rgb[i] = Math.max(Math.min(rgb[i], limit), 0);    }    public static int diff(int colorA, int colorB) {        return Math.abs(colorA - colorB);    }    public static void avg(int itt, int[] rgb) {        if (itt == 0)            return;        for (int i = 0; i < rgb.length; i++)            rgb[i] /= itt;    }    public static int getStrongest(int[] rgb) {        int strongest = 0;        int index = 0;        for (int i = 0; i < rgb.length; i++)            if (rgb[i] > strongest) {                strongest = rgb[i];                index = i;            }        return index;    }    public static int getTotal(int[] rgb) {        return rgb[0] + rgb[1] + rgb[2];    }    public static int forEachPixel(int px, int py, int pw, int ph, int xdir, int ydir, BufferedImage image, CAFunc func) {        int itt = 0;        int xStep = pw / 20;        int yStep = ph / 20;        int ix = -pw / 2;        int itterx = 0;        while (ix < pw / 2) {            int iy = -ph / 2;            int ittery = 0;            while (iy < ph / 2) {                try {                    func.Each(image.getRGB(px + ix, py + iy));                    itt++;                } catch (Exception e) {                }                ittery++;                iy += ydir == 0 ? yStep : ittery / 6 + 1;//Math.abs(iy / 4) + 1;            }            itterx++;            ix += xdir == 0 ? xStep : itterx / 6 + 1;//Math.abs(ix / 4) + 1;//4;//itterx;        }        return itt;    }    public static int[] getAvgColor(BufferedImage image, int side, int numLights, int cr, int stepX, int stepY) {        int[] avg = new int[]{0, 0, 0};        int itt = 0;        int h = stepY * numLights;        int w = stepX * numLights;        for (int i = 0; i < numLights; i++) {            switch (side) {                case 0: // Right                    itt += forEachPixel(cr, h - i * stepY - stepY / 2, cr * 2, stepY, -1, 0, image, (pixel) -> ColAlg.add(pixel, avg));                    break;                case 1: // Top                    itt += forEachPixel(w - i * stepX - stepX / 2, cr, stepX, cr * 2, 0, 1, image, (pixel) -> ColAlg.add(pixel, avg));                    break;                case 2: // Left                    itt += forEachPixel(cr, i * stepY + stepY / 2, cr * 2, stepY, 1, 0, image, (pixel) -> ColAlg.add(pixel, avg));                    break;                case 3: // Bottom                    itt += forEachPixel(i * stepX + stepX / 2, cr, stepX, cr * 2, 0, -1, image, (pixel) -> ColAlg.add(pixel, avg));                    break;            }        }        final int ittTot = itt;        forEachValue(avg, (v) ->        {            avg[v] /= ittTot;        });        return avg;    }    public static int getBrightness(int[] rgb) {        int bright = 0;        for (int aRgb : rgb) bright += aRgb;        return bright / rgb.length;    }    public static void forEachValue(int[] rgb, CAFunc func) {        for (int i = 0; i < rgb.length; i++)            func.Each(i);    }    public static void add(int pixel, int[] rgb) {        rgb[0] += (255 & (pixel >> 16));        rgb[1] += (255 & (pixel >> 8));        rgb[2] += (255 & (pixel));    }    public static void set(int pixel, int[] rgb) {        rgb[0] = (255 & (pixel >> 16));        rgb[1] = (255 & (pixel >> 8));        rgb[2] = (255 & (pixel));    }    public interface CAFunc {        public void Each(int pixel);    }}